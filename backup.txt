#!/usr/bin/env python3
import os
import sys
import re
import json
import requests
import subprocess
from pathlib import Path
from urllib.parse import quote
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import mutagen
from mutagen.id3 import ID3, TPE1, TIT2, TALB, TCON, TYER, APIC, TRCK, error
from mutagen.mp3 import MP3
import argparse
from typing import List, Dict, Optional
import time

class AdvancedSpotifyDownloader:
    def __init__(self):
        # Public Spotify API credentials (these are sample credentials)
        self.spotify_client_id = "5f573c9620494bae87890c0f08a60293"
        self.spotify_client_secret = "212476d9b0f3472eaa762d90b19b0ba8"
        
        # Set output directory to the same folder as the script
        script_dir = Path(__file__).parent.absolute()
        self.output_dir = script_dir / "Spotify Downloads"
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Check if spotdl is installed
        if not self.check_spotdl_installed():
            print("[*] spotdl is not installed. Please install it with: pip install spotdl")
            sys.exit(1)
        
        # Initialize Spotify client
        try:
            self.sp = spotipy.Spotify(
                auth_manager=SpotifyClientCredentials(
                    client_id=self.spotify_client_id,
                    client_secret=self.spotify_client_secret
                )
            )
        except Exception as e:
            print(f"[*] Error initializing Spotify client: {e}")
            print("[*] Please check your Spotify API credentials")
            sys.exit(1)
    
    def check_spotdl_installed(self) -> bool:
        """Check if spotdl is installed and available"""
        try:
            subprocess.run(["spotdl", "--version"], 
                          capture_output=True, check=True, text=True)
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False
    
    def clear_screen(self):
        """Clear the screen but keep the header"""
        os.system('cls' if os.name == 'nt' else 'clear')
        self.show_header()
    
    def show_header(self):
        """Display the header"""
        print(r"                  _      _ _ ")
        print(r"                 | |    | | |")
        print(r"  ___ _ __   ___ | |_ __| | |")
        print(r" / __| '_ \ / _ \| __/ _` | |")
        print(r" \__ \ |_) | (_) | || (_| | |")
        print(r" |___/ .__/ \___/ \__\__,_|_|")
        print(r"     | |                     ")
        print(r"     |_|                     ")
        print("     Developed by: @Finnapple")
        print()
        print("[*] Spotify Music Downloader")
        print("[*] Download your song in 320kbps using spotdl")
        print("[*] Paste Spotify URLs (track or album). Type 'exit' to quit.")
        print("[*] Type 'clear' to clear the screen.")
        print(f"[*] Downloading to: {self.output_dir}")
        print("-" * 50)
    
    def sanitize_filename(self, name: str) -> str:
        """Remove invalid characters from filename"""
        return re.sub(r'[<>:"/\\|?*]', '', name)

    def normalize(self, s: str) -> str:
        """Simple normalization for matching"""
        s = s.lower()
        s = re.sub(r'[\s\-_]+', ' ', s)
        s = re.sub(r'[^\w\s]', '', s)
        return s.strip()
    
    def download_image(self, url: Optional[str]) -> Optional[bytes]:
        if not url:
            return None
        try:
            resp = requests.get(url, timeout=10)
            if resp.status_code == 200:
                return resp.content
        except Exception:
            pass
        return None

    def apply_metadata_to_file(self, file_path: Path, meta: Dict, cover_bytes: Optional[bytes] = None):
        """Apply ID3 tags to a single file using Spotify metadata."""
        try:
            audio = MP3(file_path, ID3=ID3)
            try:
                audio.add_tags()
            except error:
                pass

            if 'title' in meta:
                audio.tags['TIT2'] = TIT2(encoding=3, text=meta['title'])
            if 'artists' in meta:
                audio.tags['TPE1'] = TPE1(encoding=3, text=meta['artists'])
            if 'album' in meta:
                audio.tags['TALB'] = TALB(encoding=3, text=meta['album'])
            if 'track_number' in meta:
                audio.tags['TRCK'] = TRCK(encoding=3, text=str(meta['track_number']))
            if 'release_date' in meta and meta['release_date']:
                year = str(meta['release_date']).split('-')[0]
                if year:
                    audio.tags['TYER'] = TYER(encoding=3, text=year)
            if cover_bytes:
                audio.tags['APIC'] = APIC(encoding=3, mime='image/jpeg', type=3, desc='Cover', data=cover_bytes)
            audio.save()
            print(f"[*] Metadata applied: {file_path.name}")
        except Exception as e:
            print(f"[*] Error applying metadata to {file_path.name}: {e}")

    def sync_track_metadata(self, track_info: Dict, directory: Path):
        """Find downloaded MP3(s) for a single track and apply Spotify metadata."""
        cover_bytes = self.download_image(track_info.get('cover_url'))
        candidates = list(directory.glob("*.mp3"))
        if not candidates:
            print("[*] No mp3 files found to tag.")
            return

        target_norm = self.normalize(track_info['title'])
        best = None
        best_score = 0
        for f in candidates:
            name_norm = self.normalize(f.stem)
            score = 0
            if target_norm in name_norm or name_norm in target_norm:
                score = 100
            else:
                # check by duration similarity
                try:
                    audio = MP3(f)
                    length = int(audio.info.length)
                    target_len = int(track_info.get('duration_ms', 0) / 1000)
                    if abs(length - target_len) <= 3:
                        score = 50
                except Exception:
                    pass
            if score > best_score:
                best_score = score
                best = f

        if best:
            meta = {
                'title': track_info['title'],
                'artists': track_info['artists'],
                'album': track_info['album'],
                'track_number': track_info.get('track_number'),
                'release_date': track_info.get('release_date')
            }
            # Optionally rename file to "Artist - Title.mp3" (sanitized)
            new_name = f"{self.sanitize_filename(track_info['artists'])} - {self.sanitize_filename(track_info['title'])}.mp3"
            new_path = directory / new_name
            try:
                if best != new_path:
                    counter = 1
                    candidate_new = new_path
                    while candidate_new.exists():
                        name_parts = new_name.rsplit('.', 1)
                        candidate_new = directory / f"{name_parts[0]} ({counter}).{name_parts[1]}"
                        counter += 1
                    best.rename(candidate_new)
                    best = candidate_new
            except Exception as e:
                print(f"[*] Could not rename file: {e}")

            self.apply_metadata_to_file(best, meta, cover_bytes)
        else:
            print("[*] Could not confidently match a downloaded file to the Spotify track.")

    def sync_album_metadata(self, album_info: Dict, directory: Path):
        """Match MP3 files in directory to album tracks and apply Spotify metadata."""
        cover_bytes = self.download_image(album_info.get('cover_url'))
        files = list(directory.glob("*.mp3"))
        if not files:
            print("[*] No mp3 files found in album directory.")
            return

        # Precompute normalized filenames and durations
        file_data = []
        for f in files:
            norm = self.normalize(f.stem)
            length = None
            try:
                audio = MP3(f)
                length = int(audio.info.length)
            except Exception:
                pass
            file_data.append({'path': f, 'norm': norm, 'length': length, 'used': False})

        for track in album_info.get('tracks', []):
            t_norm = self.normalize(track['title'])
            best = None
            best_score = -1
            for fd in file_data:
                if fd['used']:
                    continue
                score = 0
                if t_norm in fd['norm'] or fd['norm'] in t_norm:
                    score += 100
                # duration closeness
                if fd['length'] and track.get('duration_ms'):
                    target_len = int(track['duration_ms'] / 1000)
                    diff = abs(fd['length'] - target_len)
                    if diff <= 2:
                        score += 50
                    else:
                        score += max(0, 20 - diff)  # small reward for somewhat close
                if score > best_score:
                    best_score = score
                    best = fd
            if best and best_score > 0:
                meta = {
                    'title': track['title'],
                    'artists': track.get('artists') or album_info.get('artists'),
                    'album': album_info.get('name'),
                    'track_number': track.get('track_number'),
                    'release_date': album_info.get('release_date')
                }
                # rename to "Artist - Title.mp3"
                new_name = f"{self.sanitize_filename(meta['artists'])} - {self.sanitize_filename(meta['title'])}.mp3"
                new_path = directory / new_name
                try:
                    if best['path'] != new_path:
                        counter = 1
                        candidate_new = new_path
                        while candidate_new.exists():
                            name_parts = new_name.rsplit('.', 1)
                            candidate_new = directory / f"{name_parts[0]} ({counter}).{name_parts[1]}"
                            counter += 1
                        best['path'].rename(candidate_new)
                        best['path'] = candidate_new
                except Exception as e:
                    print(f"[*] Could not rename file {best['path'].name}: {e}")
                self.apply_metadata_to_file(best['path'], meta, cover_bytes)
                best['used'] = True
            else:
                print(f"[*] No good match for track: {track['title']}")

    def get_track_info(self, track_url: str) -> Optional[Dict]:
        """Get track information from Spotify"""
        try:
            track_id = track_url.split('/')[-1].split('?')[0]
            track = self.sp.track(track_id)
            
            # Format artists as comma-separated list
            artists = ", ".join([artist['name'] for artist in track['artists']])
            
            return {
                'id': track['id'],
                'title': track['name'],
                'artists': artists,
                'album': track['album']['name'],
                'release_date': track['album']['release_date'],
                'track_number': track['track_number'],
                'duration_ms': track['duration_ms'],
                'cover_url': track['album']['images'][0]['url'] if track['album']['images'] else None
            }
        except Exception as e:
            print(f"[*] Error getting track info: {e}")
            return None
    
    def get_album_info(self, album_url: str) -> Optional[Dict]:
        """Get album information from Spotify"""
        try:
            album_id = album_url.split('/')[-1].split('?')[0]
            album = self.sp.album(album_id)
            
            # Get all tracks from the album
            tracks = []
            results = self.sp.album_tracks(album_id)
            tracks.extend(results['items'])
            
            while results['next']:
                results = self.sp.next(results)
                tracks.extend(results['items'])
            
            album_info = {
                'id': album['id'],
                'name': album['name'],
                'artists': ", ".join([artist['name'] for artist in album['artists']]),
                'release_date': album['release_date'],
                'total_tracks': album['total_tracks'],
                'cover_url': album['images'][0]['url'] if album['images'] else None,
                'tracks': []
            }
            
            for track in tracks:
                track_artists = ", ".join([artist['name'] for artist in track['artists']])
                album_info['tracks'].append({
                    'id': track['id'],
                    'title': track['name'],
                    'artists': track_artists,
                    'track_number': track['track_number'],
                    'duration_ms': track['duration_ms']
                })
            
            return album_info
        except Exception as e:
            print(f"[*] Error getting album info: {e}")
            return None
    
    def download_with_spotdl(self, url: str, output_path: Path, timeout: int = 900) -> bool:
        """Download audio using spotdl while streaming stdout/stderr so progress is visible."""
        try:
            original_cwd = os.getcwd()
            os.chdir(output_path)

            # Use Popen to stream output so user can see progress
            proc = subprocess.Popen(
                ["spotdl", url, "--bitrate", "320k"],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )

            start = time.time()
            # Read lines as they arrive
            if proc.stdout:
                for line in proc.stdout:
                    line = line.rstrip()
                    if line:
                        print(line)
                    # Optional: break if too long
                    if time.time() - start > timeout:
                        proc.kill()
                        print("[*] Download timed out!")
                        os.chdir(original_cwd)
                        return False

            proc.wait()
            os.chdir(original_cwd)

            if proc.returncode == 0:
                return True
            else:
                print(f"[!] spotdl exited with code: {proc.returncode}")
                return False

        except Exception as e:
            print(f"[*] Error downloading with spotdl: {e}")
            try:
                os.chdir(original_cwd)
            except Exception:
                pass
            return False

    def download_track(self, track_url: str):
        """Download a single Spotify track and keep retrying until it's present and tagged."""
        print(f"[*] Processing track: {track_url}")
        track_info = self.get_track_info(track_url)
        if not track_info:
            print("[*] Failed to get track information")
            return False

        track_dir = self.output_dir
        track_dir.mkdir(parents=True, exist_ok=True)

        expected_name = f"{self.sanitize_filename(track_info.get('artists') or '')} - {self.sanitize_filename(track_info.get('title') or '')}.mp3"
        expected_path = track_dir / expected_name

        attempt = 1
        while True:
            # If file already exists, attempt tagging and return
            if expected_path.exists():
                try:
                    self.sync_track_metadata(track_info, track_dir)
                except Exception as e:
                    print(f"[*] Error tagging existing file: {e}")
                print(f"[+] Track already present: {expected_path.name}")
                return True

            print(f"[*] Download attempt #{attempt} for track: {track_info.get('title')}")
            ok = self.download_with_spotdl(track_url, track_dir, timeout=300)

            # After spotdl run, check for the expected file or any reasonable match
            if expected_path.exists():
                try:
                    self.sync_track_metadata(track_info, track_dir)
                except Exception as e:
                    print(f"[*] Error tagging downloaded file: {e}")
                print(f"[+] Successfully downloaded: {expected_path.name}")
                return True

            # Try a best-effort tagging even if filename differs (sync_track_metadata tries to match by content)
            try:
                self.sync_track_metadata(track_info, track_dir)
            except Exception:
                pass

            # If spotdl reported success but file not found, still continue retrying per user request
            if ok:
                # maybe spotdl created a differently named file; check for any close match
                candidates = list(track_dir.glob("*.mp3"))
                if candidates:
                    # if any file seems to match by normalization/duration, tag and return
                    for f in candidates:
                        try:
                            audio = MP3(f)
                            length = int(audio.info.length)
                        except Exception:
                            length = None
                        target_len = int(track_info.get('duration_ms', 0) / 1000) if track_info.get('duration_ms') else None
                        if target_len and length and abs(length - target_len) <= 3:
                            try:
                                self.sync_track_metadata(track_info, track_dir)
                            except Exception:
                                pass
                            print(f"[+] Found likely match: {f.name}")
                            return True

            print(f"[!] Attempt #{attempt} failed for: {track_info.get('title')}. Will retry...")
            attempt += 1
            time.sleep(2)  # small delay between retries

    def identify_missing_tracks(self, album_info: Dict, directory: Path) -> List[Dict]:
        """Return list of track dicts that appear missing in the directory (no confident match)."""
        files = list(directory.glob("*.mp3"))
        # Precompute normalized filenames, durations, and tags
        file_data = []
        for f in files:
            norm = self.normalize(f.stem)
            length = None
            tag_title = None
            tag_artist = None
            try:
                audio = MP3(f)
                length = int(audio.info.length)
            except Exception:
                pass
            # try reading ID3 tags if available
            try:
                tags = ID3(f)
                if 'TIT2' in tags:
                    tag_title = self.normalize(str(tags['TIT2'].text[0]))
                if 'TPE1' in tags:
                    tag_artist = self.normalize(str(tags['TPE1'].text[0]))
            except Exception:
                pass
            file_data.append({'path': f, 'norm': norm, 'length': length, 'tag_title': tag_title, 'tag_artist': tag_artist})

        missing = []
        for track in album_info.get('tracks', []):
            t_norm = self.normalize(track['title'])
            a_norm = self.normalize(track.get('artists') or album_info.get('artists', ''))
            found = False
            for fd in file_data:
                # 1) exact-ish title/artist tag match
                if fd['tag_title'] and fd['tag_artist']:
                    if t_norm in fd['tag_title'] or fd['tag_title'] in t_norm:
                        if a_norm in fd['tag_artist'] or fd['tag_artist'] in a_norm:
                            found = True
                            break
                # 2) filename-based match
                if t_norm in fd['norm'] or fd['norm'] in t_norm:
                    found = True
                    break
                # 3) duration heuristic
                if fd['length'] and track.get('duration_ms'):
                    target_len = int(track['duration_ms'] / 1000)
                    if abs(fd['length'] - target_len) <= 3:
                        found = True
                        break
            if not found:
                missing.append(track)
        return missing

    def download_album(self, album_url: str):
        """Download an entire album using spotdl, then retry only failed tracks until complete."""
        print(f"[*] Processing album: {album_url}")
        
        # Get album info from Spotify (for display purposes)
        album_info = self.get_album_info(album_url)
        if not album_info:
            print("[*] Failed to get album information")
            return False
        
        print(f"[*] Found album: {album_info['artists']} - {album_info['name']}")
        print(f"[*] Tracks: {album_info['total_tracks']}")
        
        # Create album directory
        album_dir = self.output_dir / self.sanitize_filename(f"{album_info['artists']} - {album_info['name']}")
        album_dir.mkdir(exist_ok=True)
        
        # Initial full-album download (streamed progress)
        print("[*] Starting album download (stream visible)...")
        success = self.download_with_spotdl(album_url, album_dir)
        
        # Always attempt to tag whatever is present
        if album_dir.exists():
            self.sync_album_metadata(album_info, album_dir)
        
        if not success:
            print("[*] Initial album download reported failure, will try per-track retries for missing tracks.")

        # Identify missing tracks and retry them individually until none remain
        attempt = 1
        while True:
            missing = self.identify_missing_tracks(album_info, album_dir)
            if not missing:
                print("[*] All tracks present. Album complete.")
                break

            print(f"[*] Attempt #{attempt}: {len(missing)} missing track(s) will be retried.")
            for track in missing:
                # For each missing track, block and retry until it is detected
                try:
                    self.retry_track_until_downloaded(track, album_info, album_dir, timeout=300)
                except Exception as e:
                    print(f"[*] Error while retrying {track['title']}: {e}")
                # small delay between track retries
                time.sleep(1)

            attempt += 1
            # small pause before re-checking to avoid busy loop
            time.sleep(2)

        # Final tagging pass to ensure metadata on all files
        self.sync_album_metadata(album_info, album_dir)
        print("[*] Album download and tagging completed!")
        return True

    # NEW helper: retry a single album track until a confident file is present
    def retry_track_until_downloaded(self, track: Dict, album_info: Dict, album_dir: Path, timeout: int = 300):
        """Keep retrying download for one track until a confident match/file exists."""
        expected_name = f"{self.sanitize_filename(track.get('artists') or album_info.get('artists'))} - {self.sanitize_filename(track['title'])}.mp3"
        expected_path = album_dir / expected_name
        track_url = f"https://open.spotify.com/track/{track['id']}"
        attempt = 1

        while True:
            # If expected file already exists, tag and return
            if expected_path.exists():
                try:
                    tinfo = {
                        'title': track['title'],
                        'artists': track.get('artists') or album_info.get('artists'),
                        'album': album_info.get('name'),
                        'track_number': track.get('track_number'),
                        'release_date': album_info.get('release_date'),
                        'duration_ms': track.get('duration_ms'),
                        'cover_url': album_info.get('cover_url')
                    }
                    self.sync_track_metadata(tinfo, album_dir)
                except Exception:
                    pass
                print(f"[+] Track present: {expected_path.name}")
                return True

            print(f"[*] Retry attempt #{attempt} for: {track['title']}")
            ok = self.download_with_spotdl(track_url, album_dir, timeout=timeout)

            # Always attempt to tag anything new (best-effort)
            try:
                tinfo = {
                    'title': track['title'],
                    'artists': track.get('artists') or album_info.get('artists'),
                    'album': album_info.get('name'),
                    'track_number': track.get('track_number'),
                    'release_date': album_info.get('release_date'),
                    'duration_ms': track.get('duration_ms'),
                    'cover_url': track.get('cover_url')
                }
                self.sync_track_metadata(tinfo, album_dir)
            except Exception:
                pass

            # If expected file now exists after tagging attempt
            if expected_path.exists():
                print(f"[+] Successfully downloaded: {expected_path.name}")
                return True

            # If spotdl reported success but filename differs, check for likely match by duration/normalization
            if ok:
                candidates = list(album_dir.glob("*.mp3"))
                for f in candidates:
                    try:
                        audio = MP3(f)
                        length = int(audio.info.length)
                    except Exception:
                        length = None
                    target_len = int(track.get('duration_ms', 0) / 1000) if track.get('duration_ms') else None
                    norm_name = self.normalize(f.stem)
                    norm_title = self.normalize(track['title'])
                    if (target_len and length and abs(length - target_len) <= 3) or (norm_title in norm_name or norm_name in norm_title):
                        # Found likely match: tag and rename
                        try:
                            self.sync_track_metadata(tinfo, album_dir)
                        except Exception:
                            pass
                        print(f"[+] Found likely match for {track['title']}: {f.name}")
                        return True

            # Otherwise, keep retrying indefinitely (per user request)
            print(f"[!] Attempt #{attempt} failed for {track['title']}. Will retry...")
            attempt += 1
            time.sleep(2)

    def process_url(self, url: str):
        """Process a Spotify URL (track or album)"""
        if 'track' in url:
            return self.download_track(url)
        elif 'album' in url:
            return self.download_album(url)
        else:
            print("[*] Unsupported Spotify URL. Please provide a track or album link.")
            return False

def main():
    parser = argparse.ArgumentParser(description='Advanced Spotify Downloader')
    parser.add_argument('url', nargs='?', help='Spotify track or album URL')
    parser.add_argument('--file', '-f', help='Text file containing multiple Spotify URLs')
    
    args = parser.parse_args()
    
    downloader = AdvancedSpotifyDownloader()
    
    if args.file:
        # Process multiple URLs from a file
        try:
            with open(args.file, 'r') as f:
                urls = [line.strip() for line in f if line.strip()]
            
            for url in urls:
                print(f"\n{'='*50}")
                downloader.process_url(url)
                print(f"{'='*50}\n")
                
        except FileNotFoundError:
            print(f"[*] File not found: {args.file}")
        except Exception as e:
            print(f"[*] Error processing file: {e}")
    
    elif args.url:
        # Process a single URL
        downloader.process_url(args.url)
    
    else:
        # Interactive mode
        downloader.show_header()
        
        while True:
            try:
                url = input("\n[*] Enter Spotify URL: ").strip()
                
                if url.lower() in ['exit', 'quit', 'q']:
                    break
                
                if url.lower() in ['clear', 'cls']:
                    downloader.clear_screen()
                    continue
                
                if not url:
                    continue
                
                downloader.process_url(url)
                
            except KeyboardInterrupt:
                print("\n[*] Exiting...")
                break
            except Exception as e:
                print(f"[*] Error: {e}")

if __name__ == "__main__":
    main()